## FIXME Move SCE method to basejump, so we can use with Chromium.
## FIXME nGene to nFeature
## FIXME log10GenesPerUMI to log10FeaturesPerUMI
## FIXME Rework to not use dplyr / tibble here.
## FIXME Look for nUMI and use that first, otherwise pick nCount
## FIXME Look for nGene and use that, otherwise pick nFeature
## FIXME Look for log10GenesPerUMI, log10FeaturesPerUMI


#' @name filterCells
#' @author Michael Steinbaugh
#' @inherit bioverbs::filterCells
#' @note Updated 2019-08-08.
#'
#' @details
#' Apply gene detection, novelty score, and mitochondrial abundance cutoffs to
#' cellular barcodes. By default we recommend applying the same filtering cutoff
#' to all samples. The filtering parameters now support per-sample cutoffs,
#' defined using a named `numeric` vector. When matching per sample, be sure to
#' use the [sampleNames()] return values (i.e. the `sampleName` column in
#' [sampleData()]).
#'
#' @inheritParams acidroxygen::params
#' @param nCells `integer(1)`.
#'   Expected number of cells per sample.
#'   Don't set this by default, unless you're confident of your capture.
#' @param minCounts,maxCounts `integer(1)`.
#'   Minimum/maximum number of counts per cell.
#'   Applies to UMI disambiguated counts for droplet scRNA-seq.
#'   Matches `nUMI` then `nCount` column in
#'   [`colData()`][SummarizedExperiment] internally.
#'   Previously named `minUMIs`/`maxUMIs` in bcbioSingleCell.
#' @param minFeatures,maxFeatures `integer(1)`.
#'   Minimum/maximum number of features (i.e. genes) detected.
#'   Matches `nFeature`in [`colData()`][SummarizedExperiment] internally.
#'   Previously named `minGenes`/`maxGenes` in bcbioSingleCell.
#' @param minNovelty `integer(1)` (`0`-`1`).
#'   Minimum novelty score (log10 features per UMI).
#'   Matches `log10FeaturesPerCount` then `log10FeaturesPerUMI` (legacy)
#'   [`colData()`][SummarizedExperiment] internally.
#' @param maxMitoRatio `integer(1)` (`0`-`1`).
#'   Maximum relative mitochondrial abundance.
#' @param minCellsPerFeature `integer(1)`.
#'   Include genes with non-zero expression in at least this many cells.
#'   Previously named `minCellsPerGene` in bcbioSingleCell.
#' @param ... Additional arguments.
#'
#' @return `SingleCellExperiment`.
#' Filtering information gets slotted into [`metadata()`][S4Vectors::metadata]
#' as `filterCells` metadata.
#'
#' @examples
#' data(SingleCellExperiment, package = "acidtest")
#'
#' ## SingleCellExperiment ====
#' object <- SingleCellExperiment
#' object <- calculateMetrics(object)
#'
#' show(object)
#' x <- filterCells(object)
#' show(x)
#'
#' ## Per sample cutoffs.
#' sampleNames(object)
#' x <- filterCells(
#'     object = object,
#'     minCounts = c(sample1 = 100L)
#' )
#' show(x)
NULL



#' @rdname filterCells
#' @name filterCells
#' @importFrom bioverbs filterCells
#' @usage filterCells(object, ...)
#' @export
NULL



## Updated 2019-08-08.
.isFiltered <- function(object) {
    if (!is.null(metadata(object)[["filterCells"]])) {
        TRUE
    } else {
        FALSE
    }
}



## Updated 2019-07-24.
.paddedCount <- function(x, width = 8L) {
    str_pad(x, width = width, pad = " ")
}



## Updated 2019-08-08.
`filterCells,SingleCellExperiment` <-  # nolint
    function(
        object,
        nCells = Inf,
        minCounts = 1L,
        maxCounts = Inf,
        minFeatures = 1L,
        maxFeatures = Inf,
        minNovelty = 0L,
        maxMitoRatio = 1L,
        minCellsPerFeature = 1L
    ) {
        validObject(object)
        assert(
            ## Expected nCells per sample.
            is.numeric(nCells),
            all(isPositive(nCells)),
            ## minCounts (see below)
            isAny(minCounts, c("numeric", "character")),
            ## maxCounts
            is.numeric(maxCounts),
            all(isPositive(maxCounts)),
            ## minFeatures
            is.numeric(minFeatures),
            all(isPositive(minFeatures)),
            ## maxGenes
            is.numeric(maxFeatures),
            all(isNonNegative(maxFeatures)),
            ## minNovelty
            is.numeric(minNovelty),
            all(isInRange(minNovelty, lower = 0L, upper = 1L)),
            ## maxMitoRatio
            is.numeric(maxMitoRatio),
            ## Don't allow the user to set at 0.
            all(isInLeftOpenRange(maxMitoRatio, lower = 0L, upper = 1L)),
            ## minCellsPerGene
            is.numeric(minCellsPerFeature),
            ## Don't allow genes with all zero counts.
            all(isPositive(minCellsPerFeature))
        )
        ## minCounts supports barcode ranks filtering.
        if (is.character(minCounts)) {
            assert(
                isString(minCounts),
                isSubset(minCounts, c("inflection", "knee"))
            )
        } else {
            assert(
                is.numeric(minCounts),
                all(isPositive(minCounts))
            )
        }

        originalDim <- dim(object)
        sampleNames <- sampleNames(object)
        colData <- colData(object)

        ## Check to see if `calculateMetrics()` needs to be run on the object.
        if (!isSubset(c("nCount", "nFeature"), colnames(colData))) {
            stop("`calculateMetrics()` needs to be run on this object.")
        }

        params <- list(
            nCells = nCells,
            minCounts = minCounts,
            maxCounts = maxCounts,
            minFeatures = minFeatures,
            maxFeatures = maxFeatures,
            minNovelty = minNovelty,
            maxMitoRatio = maxMitoRatio,
            minCellsPerFeature = minCellsPerFeature
        )

        ## Filter low quality cells --------------------------------------------
        summaryCells <- character()
        summaryCells[["prefilter"]] <- paste(
            paste(.paddedCount(ncol(object)), "cells"),
            "prefilter",
            sep = " | "
        )

        ## minCounts
        if (isString(minCounts)) {
            ranks <- barcodeRanksPerSample(object)
            minCounts <- vapply(
                X = ranks,
                FUN = function(x) {
                    as.integer(x[[minCounts]])
                },
                FUN.VALUE = integer(1L)
            )
            names(minCounts) <- sampleNames
            minCounts <- minCounts[sort(names(minCounts))]
        }
        if (!is.null(names(minCounts))) {
            assert(areSetEqual(names(minCounts), sampleNames))
            message(paste(
                "minCounts: per sample mode",
                printString(minCounts),
                sep = "\n"
            ))
            list <- mapply(
                sample = names(minCounts),
                cutoff = minCounts,
                FUN = function(sample, cutoff) {
                    filter(
                        colData,
                        !!sym("sampleName") == !!sample,
                        !!sym("nUMI") >= !!cutoff
                    )
                },
                SIMPLIFY = FALSE,
                USE.NAMES = FALSE
            )
            colData <- bind_rows(list)
        } else {
            colData <- filter(colData, !!sym("nUMI") >= !!minCounts)
        }
        if (!nrow(colData)) {
            stop("No cells passed `minCounts` cutoff")
        }
        summaryCells[["minCounts"]] <- paste(
            paste(.paddedCount(nrow(colData)), "cells"),
            paste("minCounts", ">=", min(minCounts)),
            sep = " | "
        )

        ## maxCounts
        if (!is.null(names(maxCounts))) {
            assert(areSetEqual(names(maxCounts), sampleNames))
            message(paste(
                "maxCounts: per sample mode",
                printString(maxCounts),
                sep = "\n"
            ))
            list <- mapply(
                sample = names(maxCounts),
                cutoff = maxCounts,
                FUN = function(sample, cutoff) {
                    filter(
                        colData,
                        !!sym("sampleName") == !!sample,
                        !!sym("nUMI") <= !!cutoff
                    )
                },
                SIMPLIFY = FALSE,
                USE.NAMES = FALSE
            )
            colData <- bind_rows(list)
        } else {
            colData <- filter(colData, !!sym("nUMI") <= !!maxCounts)
        }
        if (!nrow(colData)) {
            stop("No cells passed `maxCounts` cutoff")
        }
        summaryCells[["maxCounts"]] <- paste(
            paste(.paddedCount(nrow(colData)), "cells"),
            paste("maxCounts", "<=", max(maxCounts)),
            sep = " | "
        )

        ## minGenes
        if (!is.null(names(minGenes))) {
            assert(areSetEqual(names(minGenes), sampleNames))
            message(paste(
                "minGenes: per sample mode",
                printString(minGenes),
                sep = "\n"
            ))
            list <- mapply(
                sample = names(minGenes),
                cutoff = minGenes,
                FUN = function(sample, cutoff) {
                    filter(
                        colData,
                        !!sym("sampleName") == !!sample,
                        !!sym("nGene") >= !!cutoff
                    )
                },
                SIMPLIFY = FALSE,
                USE.NAMES = FALSE
            )
            colData <- bind_rows(list)
        } else {
            colData <- filter(colData, !!sym("nGene") >= !!minGenes)
        }
        if (!nrow(colData)) {
            stop("No cells passed `minGenes` cutoff")
        }
        summaryCells[["minGenes"]] <- paste(
            paste(.paddedCount(nrow(colData)), "cells"),
            paste("minGenes", ">=", min(minGenes)),
            sep = " | "
        )

        ## maxGenes
        if (!is.null(names(maxGenes))) {
            assert(areSetEqual(names(maxGenes), sampleNames))
            message(paste(
                "maxGenes: per sample mode",
                printString(maxGenes),
                sep = "\n"
            ))
            list <- mapply(
                sample = names(maxGenes),
                cutoff = maxGenes,
                FUN = function(sample, cutoff) {
                    filter(
                        colData,
                        !!sym("sampleName") == !!sample,
                        !!sym("nGene") <= !!cutoff
                    )
                },
                SIMPLIFY = FALSE,
                USE.NAMES = FALSE
            )
            colData <- bind_rows(list)
        } else {
            colData <- filter(colData, !!sym("nGene") <= !!maxGenes)
        }
        if (!nrow(colData)) {
            stop("No cells passed `maxGenes` cutoff")
        }
        summaryCells[["maxGenes"]] <- paste(
            paste(.paddedCount(nrow(colData)), "cells"),
            paste("maxGenes", "<=", max(maxGenes)),
            sep = " | "
        )

        ## minNovelty
        if (!is.null(names(minNovelty))) {
            assert(areSetEqual(names(minNovelty), sampleNames))
            message(paste(
                "minNovelty: per sample mode",
                printString(minNovelty),
                sep = "\n"
            ))
            list <- mapply(
                sample = names(minNovelty),
                cutoff = minNovelty,
                FUN = function(sample, cutoff) {
                    filter(
                        colData,
                        !!sym("sampleName") == !!sample,
                        !!sym("log10GenesPerUMI") >= !!cutoff)
                },
                SIMPLIFY = FALSE,
                USE.NAMES = FALSE
            )
            colData <- bind_rows(list)
        } else {
            colData <- filter(
                colData,
                !!sym("log10GenesPerUMI") >= !!minNovelty
            )
        }
        if (!nrow(colData)) {
            stop("No cells passed `minNovelty` cutoff")
        }
        summaryCells[["minNovelty"]] <- paste(
            paste(.paddedCount(nrow(colData)), "cells"),
            paste("minNovelty", "<=", min(minNovelty)),
            sep = " | "
        )

        ## maxMitoRatio
        if (!is.null(names(maxMitoRatio))) {
            assert(areSetEqual(names(maxMitoRatio), sampleNames))
            message(paste(
                "maxMitoRatio: per sample mode",
                printString(maxMitoRatio),
                sep = "\n"
            ))
            list <- mapply(
                sample = names(maxMitoRatio),
                cutoff = maxMitoRatio,
                FUN = function(sample, cutoff) {
                    filter(
                        colData,
                        !!sym("sampleName") == !!sample,
                        !!sym("mitoRatio") <= !!cutoff
                    )
                },
                SIMPLIFY = FALSE,
                USE.NAMES = FALSE
            )
            colData <- bind_rows(list)
        } else {
            colData <- filter(colData, !!sym("mitoRatio") <= !!maxMitoRatio)
        }
        if (!nrow(colData)) {
            stop("No cells passed `maxMitoRatio` cutoff")
        }
        summaryCells[["maxMitoRatio"]] <- paste(
            paste(.paddedCount(nrow(colData)), "cells"),
            paste("maxMitoRatio", "<=", max(maxMitoRatio)),
            sep = " | "
        )

        ## Expected nCells per sample (filtered by top nUMI)
        if (nCells < Inf) {
            colData <- colData %>%
                group_by(!!sym("sampleID")) %>%
                arrange(desc(!!sym("nUMI")), .by_group = TRUE) %>%
                slice(seq_len(nCells))
        }

        if (!nrow(colData)) {
            stop("No cells passed `nCells` cutoff")
        }
        summaryCells[["nCells"]] <- paste(
            paste(.paddedCount(nrow(colData)), "cells"),
            paste("nCells", "==", nCells),
            sep = " | "
        )

        ## Now coerce back to DataFrame from tibble.
        colData <- as(colData, "DataFrame")
        assert(hasRownames(colData))
        cells <- sort(rownames(colData))
        assert(isSubset(cells, colnames(object)))
        object <- object[, cells, drop = FALSE]

        ## Filter low quality genes --------------------------------------------
        summaryGenes <- character()
        summaryGenes[["prefilter"]] <- paste(
            paste(.paddedCount(nrow(object)), "genes"),
            "prefilter",
            sep = " | "
        )
        if (minCellsPerGene > 0L) {
            nonzero <- counts(object) > 0L
            keep <- rowSums(nonzero) >= minCellsPerGene
            genes <- names(keep)[keep]
        } else {
            genes <- rownames(object)
        }
        if (!length(genes)) {
            stop("No genes passed `minCellsPerGene` cutoff")
        }
        summaryGenes[["minCellsPerGene"]] <- paste(
            paste(.paddedCount(length(genes)), "genes"),
            paste("minCellsPerGene", ">=", as.character(minCellsPerGene)),
            sep = " | "
        )
        genes <- sort(genes)
        assert(isSubset(genes, rownames(object)))
        object <- object[genes, , drop = FALSE]

        ## Summary -------------------------------------------------------------
        summaryParams <- paste("  -", c(
            paste(">=", min(minCounts), "UMIs per cell"),
            paste("<=", max(maxCounts), "UMIs per cell"),
            paste(">=", min(minGenes), "genes per cell"),
            paste("<=", max(maxGenes), "genes per cell"),
            paste(">=", min(minNovelty), "novelty score"),
            paste("<=", max(maxMitoRatio), "mitochondrial abundance"),
            paste("==", nCells, "cells per sample"),
            paste(">=", min(minCellsPerGene), "cells per gene")
        ))
        summary <- c(
            "Parameters:",
            summaryParams,
            separatorBar,
            "Cells:",
            as.character(summaryCells),
            paste(
                .paddedCount(dim(object)[[2L]]), "of", originalDim[[2L]],
                "cells passed filtering",
                paste0(
                    "(", percent(dim(object)[[2L]] / originalDim[[2L]]), ")"
                )
            ),
            ## Number of cells per sample.
            printString(table(colData[["sampleName"]])),
            separatorBar,
            "Genes:",
            as.character(summaryGenes),
            paste(
                .paddedCount(dim(object)[[1L]]), "of", originalDim[[1L]],
                "genes passed filtering",
                paste0(
                    "(", percent(dim(object)[[1L]] / originalDim[[1L]]), ")"
                )
            )
        )
        message(paste(summary, collapse = "\n"))

        ## Metadata ------------------------------------------------------------
        metadata(object)[["cellularBarcodes"]] <- NULL
        metadata(object)[["filterCells"]] <- cells
        metadata(object)[["filterGenes"]] <- genes
        metadata(object)[["filterParams"]] <- params
        metadata(object)[["filterSummary"]] <- summary

        object
    }



#' @rdname filterCells
#' @export
setMethod(
    f = "filterCells",
    signature = signature("SingleCellExperiment"),
    definition = `filterCells,SingleCellExperiment`
)
