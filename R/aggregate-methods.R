#' Aggregate Rows or Columns
#'
#' Aggregate gene/transcript features (rows) or sample replicates (columns).
#'
#' `aggregateRows()` works down the rows, and is designed to aggregate features
#' (e.g. genes or transcripts). Most commonly, the `aggregateRows()` function
#' can be used to aggregate counts from transcript-level to gene-level.
#'
#' `aggregateCols()` works across the columns, and is designed to aggregate
#' sample replicates.
#'
#' @name aggregate
#' @author Michael Steinbaugh, Rory Kirchner
#' @inheritParams params
#'
#' @section Methods (by class):
#'
#' - `matrix`, `sparseMatrix`: Aggregate rows or columns using a grouping
#'   `factor`.
#' - `SummarizedExperiment`: Aggregate rows or columns in `assays` using an
#'   automatically generated grouping `factor`, which is obtained from a
#'   user-defined column (`col` argument) in either `rowData()` or `colData()`.
#'   Slot an `aggregate` column into `rowData()` for `aggregateRows()`, or into
#'   `colData()` for `aggregateCols()`. This method will define the `groupings`
#'   automatically and perform the aggregation.
#' - `SingleCellExperiment`: Aggregate `assays()` across cell-level groupings,
#'   defined by a column in `colData()`. Inherits from `SummarizedExperiment`,
#'   and still relies upon slotting an `aggregate` column into `colData()`.
#'   Note that these groupings will map to cells, so care must be taken to
#'   properly aggregate samples.
#'
#' @param groupings `factor`. Defines the aggregation groupings. The new
#'   aggregate names are defined as the `factor` `levels`, and the original,
#'   unaggregated names are defined as the `names`.
#' @param col `string`. Name of column in either `rowData()` or `colData()` that
#'   defines the desired aggregation groupings.
#' @param fun `string`. Name of the aggregation function. Uses `match.arg()`.
#'
#' @seealso
#' - `stats::aggregate()`.
#' - `S4Vectors::aggregate()`.
#' - `Matrix.utils::aggregate.Matrix()`.
#'
#' @return Modified object, with aggregated rows (features) or columns
#'   (samples).
#'
#' @examples
#' ## Example data ====
#' counts <- matrix(
#'     data = c(
#'         0L, 1L, 1L, 1L,
#'         1L, 0L, 1L, 1L,
#'         1L, 1L, 0L, 1L,
#'         1L, 1L, 1L, 0L
#'     ),
#'     nrow = 4L,
#'     ncol = 4L,
#'     byrow = TRUE,
#'     dimnames = list(
#'         paste0("transcript", seq_len(4L)),
#'         paste(
#'             paste0("sample", rep(seq_len(2L), each = 2L)),
#'             paste0("replicate", rep(seq_len(2L), times = 2L)),
#'             sep = "_"
#'         )
#'     )
#' )
#' print(counts)
#'
#' genes <- factor(paste0("gene", rep(seq_len(2L), each = 2L)))
#' names(genes) <- rownames(counts)
#' print(genes)
#'
#' samples <- factor(paste0("sample", rep(seq_len(2L), each = 2L)))
#' names(samples) <- colnames(counts)
#' print(samples)
#'
#' cells <- factor(paste0("cell", rep(seq_len(2L), each = 2L)))
#' names(samples) <- colnames(counts)
#' print(samples)
#'
#' ## matrix
#' matrix <- as(counts, "matrix")
#' class(matrix)
#' print(matrix)
#'
#' ## sparseMatrix
#' sparse <- as(matrix, "sparseMatrix")
#' class(sparse)
#' print(sparse)
#'
#' ## SummarizedExperiment
#' se <- SummarizedExperiment::SummarizedExperiment(
#'     assay = list(counts = sparse),
#'     colData = S4Vectors::DataFrame(
#'         sampleName = names(samples),
#'         aggregate = samples
#'     ),
#'     rowData = S4Vectors::DataFrame(aggregate = genes)
#' )
#' print(se)
#'
#' ## aggregateRows ====
#' aggregateRows(matrix, groupings = genes)
#' aggregateRows(sparse, groupings = genes)
#' aggregateRows(se)
#'
#' ## aggregateCols ====
#' aggregateCols(matrix, groupings = samples)
#' aggregateCols(sparse, groupings = samples)
#' aggregateCols(se)
NULL



.aggregateFuns <- c("sum", "mean")

# Don't message when aggregating a large factor.
.aggregateMessage <- function(groupings, fun) {
    assertFactor(groupings)
    assertString(fun)
    msg <- paste0("Aggregating counts using `", fun, "()`.")
    if (length(groupings) <= 20L) {
        msg <- paste(
            msg,
            "Groupings:",
            printString(groupings),
            sep = "\n"
        )
    }
    message(msg)
}



# aggregateRows ================================================================
aggregateRows.matrix <-  # nolint
    function(
        object,
        groupings,
        fun
    ) {
        assertHasValidDimnames(object)
        assertFactor(groupings)
        assertIdentical(rownames(object), names(groupings))
        assertValidNames(levels(groupings))
        fun <- match.arg(fun)
        .aggregateMessage(groupings, fun = fun)
        # `stats::aggregate.data.frame` S3 method.
        aggregate(
            x = object,
            by = list(rowname = groupings),
            FUN = getFromNamespace(x = fun, ns = "base")
        ) %>%
            column_to_rownames() %>%
            as.matrix()
    }

formals(aggregateRows.matrix)[["fun"]] <- .aggregateFuns

#' @rdname aggregate
#' @export
setMethod(
    f = "aggregateRows",
    signature = signature("matrix"),
    definition = aggregateRows.matrix
)



aggregateRows.sparseMatrix <-  # nolint
    function(
        object,
        groupings,
        fun
    ) {
        validObject(object)
        assertHasValidDimnames(object)
        assertFactor(groupings)
        assertIdentical(rownames(object), names(groupings))
        assertValidNames(levels(groupings))
        fun <- match.arg(fun)
        .aggregateMessage(groupings, fun = fun)
        # `Matrix.utils::aggregate.Matrix` S3 method.
        aggregate(
            x = object,
            groupings = groupings,
            fun = fun
        )
    }

formals(aggregateRows.sparseMatrix)[["fun"]] <- .aggregateFuns

#' @rdname aggregate
#' @export
setMethod(
    f = "aggregateRows",
    signature = signature("sparseMatrix"),
    definition = aggregateRows.sparseMatrix
)



aggregateRows.SummarizedExperiment <-  # nolint
    function(object, col = "aggregate", fun) {
        validObject(object)
        assertHasValidDimnames(object)
        assertString(col)
        fun <- match.arg(fun)

        # Groupings ------------------------------------------------------------
        assertSubset(col, colnames(rowData(object)))
        groupings <- rowData(object)[[col]]
        assertFactor(groupings)
        assertAreValidNames(levels(groupings))
        names(groupings) <- rownames(object)

        # Assays ---------------------------------------------------------------
        counts <- aggregateRows(
            object = counts(object),
            groupings = groupings,
            fun = fun
        )
        if (fun == "sum") {
            assertIdentical(
                x = sum(counts),
                y = sum(counts(object))
            )
        }
        rownames <- rownames(counts)

        # Return ---------------------------------------------------------------
        args <- list(
            assays = list(counts = counts),
            colData = colData(object)
        )
        if (is(object, "RangedSummarizedExperiment")) {
            args[["rowRanges"]] <- emptyRanges(names = rownames)
        } else {
            args[["rowData"]] <- DataFrame(row.names = rownames)
        }
        se <- do.call(what = SummarizedExperiment, args = args)
        validObject(se)
        se
    }

formals(aggregateRows.SummarizedExperiment)[["fun"]] <- .aggregateFuns

#' @rdname aggregate
#' @export
setMethod(
    f = "aggregateRows",
    signature = signature("SummarizedExperiment"),
    definition = aggregateRows.SummarizedExperiment
)



# aggregateCols ================================================================
aggregateCols.matrix <-  # nolint
    function(
        object,
        groupings,
        fun
    ) {
        fun <- match.arg(fun)
        object %>%
            t() %>%
            aggregateRows(
                object = .,
                groupings = groupings,
                fun = fun
            ) %>%
            t()
    }

formals(aggregateCols.matrix)[["fun"]] <- .aggregateFuns

#' @rdname aggregate
#' @export
setMethod(
    f = "aggregateCols",
    signature = signature("matrix"),
    definition = aggregateCols.matrix
)



aggregateCols.sparseMatrix <-  # nolint
    function(
        object,
        groupings,
        fun
    ) {
        fun <- match.arg(fun)
        object %>%
            Matrix::t(.) %>%
            aggregateRows(
                object = .,
                groupings = groupings,
                fun = fun
            ) %>%
            Matrix::t(.)
    }

formals(aggregateCols.sparseMatrix)[["fun"]] <- .aggregateFuns

#' @rdname aggregate
#' @export
setMethod(
    f = "aggregateCols",
    signature = signature("sparseMatrix"),
    definition = aggregateCols.sparseMatrix
)



aggregateCols.SummarizedExperiment <-  # nolint
    function(object, col = "aggregate", fun) {
        validObject(object)
        assertHasValidDimnames(object)
        assert_is_a_string(col)
        fun <- match.arg(fun)

        # Groupings ------------------------------------------------------------
        assert_is_subset(col, colnames(colData(object)))
        assert_is_subset(col, colnames(sampleData(object)))
        groupings <- colData(object)[[col]]
        assert_is_factor(groupings)
        assertAreValidNames(levels(groupings))
        names(groupings) <- colnames(object)

        # Assays ---------------------------------------------------------------
        counts <- aggregateCols(
            object = counts(object),
            groupings = groupings,
            fun = fun
        )
        if (fun == "sum") {
            assertIdentical(
                x = sum(counts),
                y = sum(counts(object))
            )
        }

        # Column data ----------------------------------------------------------
        # Reslot with minimal sample-level data only.
        sampleNames <- sampleData(object)[["aggregate"]]
        assert_is_factor(sampleNames)
        sampleNames <- levels(sampleNames)
        sampleData <- DataFrame(
            sampleName = sampleNames,
            row.names = makeNames(sampleNames)
        )
        assertIdentical(
            x = rownames(sampleData),
            y = colnames(counts)
        )

        # Collapse the sample data. This step will replace the `sampleName`
        # column with the `aggregate` column metadata.
        interestingGroups <- setdiff(interestingGroups(object), "sampleName")
        sampleData <- sampleData(object) %>%
            as_tibble() %>%
            select(!!!syms(unique(c("aggregate", interestingGroups)))) %>%
            unique() %>%
            mutate(rowname = makeNames(!!sym("aggregate"))) %>%
            rename(sampleName = !!sym("aggregate")) %>%
            arrange(!!!syms(c("rowname", "sampleName"))) %>%
            mutate_all(as.factor) %>%
            mutate_all(droplevels) %>%
            as("DataFrame")
        assertHasRownames(sampleData)

        # Return ---------------------------------------------------------------
        args <- list(
            assays = list(counts = counts),
            colData = sampleData
        )
        if (is(object, "RangedSummarizedExperiment")) {
            args[["rowRanges"]] <- rowRanges(object)
        } else {
            args[["rowData"]] <- rowData(object)
        }
        se <- do.call(what = SummarizedExperiment, args = args)
        metadata(se)[["aggregate"]] <- TRUE
        validObject(se)
        se
    }

formals(aggregateCols.SummarizedExperiment)[["fun"]] <- .aggregateFuns

#' @rdname aggregate
#' @export
setMethod(
    f = "aggregateCols",
    signature = signature("SummarizedExperiment"),
    definition = aggregateCols.SummarizedExperiment
)



aggregateCols.SingleCellExperiment <-  # nolint
    function(object, fun) {
        validObject(object)
        fun <- match.arg(fun)

        # Remap cellular barcode groupings -------------------------------------
        colData <- colData(object)
        assert_is_subset(c("sampleID", "aggregate"), colnames(colData))
        assert_is_factor(colData[["aggregate"]])

        message(paste(
            "Remapping cells to aggregate samples:",
            toString(sort(levels(colData[["aggregate"]])))
        ))

        map <- colData(object) %>%
            as_tibble(rownames = "cellID") %>%
            select(!!!syms(c("cellID", "sampleID", "aggregate")))

        # Check to see if we can aggregate.
        if (!all(mapply(
            FUN = grepl,
            x = map[["cellID"]],
            pattern = paste0("^", map[["sampleID"]]),
            SIMPLIFY = TRUE
        ))) {
            stop("Cell IDs are not prefixed with sample IDs.")
        }
        groupings <- mapply(
            FUN = gsub,
            x = map[["cellID"]],
            pattern = paste0("^", map[["sampleID"]]),
            replacement = map[["aggregate"]],
            SIMPLIFY = TRUE,
            USE.NAMES = TRUE
        )
        groupings <- as.factor(groupings)

        cell2sample <- as.factor(map[["aggregate"]])
        names(cell2sample) <- as.character(groupings)

        # Reslot the `aggregate` column using these groupings.
        assertIdentical(names(groupings), colnames(object))
        colData(object)[["aggregate"]] <- groupings

        # Generate SingleCellExperiment ----------------------------------------
        # Using `SummarizedExperiment` method here.
        rse <- aggregateCols(
            object = as(object, "RangedSummarizedExperiment"),
            fun = fun
        )
        assert_is_all_of(rse, "RangedSummarizedExperiment")

        # Update the sample data.
        colData <- colData(rse)
        colData[["sampleID"]] <- cell2sample
        colData[["sampleName"]] <- colData[["sampleID"]]

        # Now ready to generate aggregated SCE.
        sce <- makeSingleCellExperiment(
            assays = assays(rse),
            rowRanges = rowRanges(object),
            colData = colData(rse),
            metadata = list(
                aggregate = TRUE,
                aggregateCols = groupings,
                interestingGroups = interestingGroups(object)
            ),
            spikeNames = spikeNames(object)
        )
        validObject(sce)
        sce
    }

formals(aggregateCols.SingleCellExperiment)[["fun"]] <- .aggregateFuns

#' @rdname aggregate
#' @export
setMethod(
    f = "aggregateCols",
    signature = signature("SingleCellExperiment"),
    definition = aggregateCols.SingleCellExperiment
)



# aggregateCellsToSamples ======================================================
#' Aggregate Cells to Samples
#'
#' Utilty function that factilites cell-to-sample aggregation. By default, this
#' function will sum the counts across cells to sample level.
#'
#' This function is intended primarily for quality control analysis.
#'
#' Internally it automatically obtains the cell-to-sample groupings and then
#' performs aggregation with the `aggregateCols()` function.
#'
#' @name aggregateCellsToSamples
#' @inheritParams aggregate
#' @inheritParams params
#'
#' @return `SummarizedExperiment`. Object with cell-level counts aggregated
#'   to sample-level.
#'
#' @examples
#' data(sce)
#' x <- aggregateCellsToSamples(sce)
#' print(x)
NULL



aggregateCellsToSamples.SingleCellExperiment <-  # nolint
    function(object, fun) {
        validObject(object)
        fun <- match.arg(fun)
        rse <- as(object, "RangedSummarizedExperiment")
        colData(rse)[["aggregate"]] <- cell2sample(object)
        aggregateCols(
            object = rse,
            col = "aggregate",
            fun = fun
        )
    }

formals(aggregateCellsToSamples.SingleCellExperiment)[["fun"]] <- .aggregateFuns



#' @rdname aggregateCellsToSamples
#' @export
setMethod(
    f = "aggregateCellsToSamples",
    signature = signature("SingleCellExperiment"),
    definition = aggregateCellsToSamples.SingleCellExperiment
)
